# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2012-2023, Paul Ramsey | Mark Leslie | PostGIS contributors
# This file is distributed under the same license as the Introduction to PostGIS package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Introduction to PostGIS 1.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-01-22 04:09-0500\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../en/rasters.rst:4
msgid "Rasters"
msgstr ""

#: ../../en/rasters.rst:6
msgid "PostGIS supports another kind of spatial data type called a *raster*. Raster data, much like geometry data, uses **Cartesian coordinates** and a spatial reference system. However instead of vector data, raster data is represented as an n-dimensional matrix consisting of pixels and bands. The bands defines the number of matrices you have. Each pixel stores a value corresponding to each band. So a 3-banded raster such as an RGB image, would have 3 values for each pixel corresponding to the Red-Green-Blue bands."
msgstr ""

#: ../../en/rasters.rst:12
msgid "Although pretty pictures such as those you see on your TV screen are rasters, rasters may not be that exciting to look at. In a nutshell, a raster is a matrix, pinned on a coordinate system, that has values that can represent anything you want them to represent."
msgstr ""

#: ../../en/rasters.rst:17
msgid "Since rasters live in cartesian space, rasters can interact with geometries. PostGIS offers many functions that take as input both rasters and geometries. Many operations applied to rasters will result in geometries. Common ones are the `ST_Polygon`, `ST_Envelope`, `ST_ConvexHull`, and `ST_MinConvexHull` as shown below.  When you cast a raster to a geometry, what is output is the `ST_ConvexHull` of the raster."
msgstr ""

#: ../../en/rasters.rst:24
msgid "The raster format is commonly used to store elevation data, temperature data, satellite data, and thematic data representing things like environmental contamination, population density, and environmental hazard occurrences. You can use rasters to store any numeric data that has a meaningful coordinate location. The only restriction is that for all data in a specific band the numeric data types have to be the same."
msgstr ""

#: ../../en/rasters.rst:28
msgid "Although raster data can be created from scratch in PostGIS, a more common approach is to load raster data from various formats using the :command:`raster2pgsql` command line tool packaged with PostGIS. Before all of that, you must enable raster support in your database by running the command:"
msgstr ""

#: ../../en/rasters.rst:37
msgid "Creating Rasters From Geometries"
msgstr ""

#: ../../en/rasters.rst:38
msgid "We'll start off by first creating raster data from vector data, and then move on to the more exciting approach of loading data from a raster source. You will find that raster data is available in abundance and often free from various government sites."
msgstr ""

#: ../../en/rasters.rst:41
msgid "We'll start by converting some geometries into rasters using `ST_AsRaster <https://postgis.net/docs/RT_ST_AsRaster.html>`_ function as follows."
msgstr ""

#: ../../en/rasters.rst:55
msgid "The above example CREATEs a table (**rasters**) from geometries formed from letters using the PostGIS 3.2+ `ST_Letters <https://postgis.net/docs/ST_Letters.html>`_ function. Rasters similar to geometries, can take advantage of spatial indexes. The spatial index used for raster is a functional index that indexes the geometry convexhull of the raster."
msgstr ""

#: ../../en/rasters.rst:58
msgid "You can see some useful metadata of your rasters with the following query which utilizes the postgis raster `ST_Count <https://postgis.net/docs/RT_ST_Count.html>`_ function to count the number of pixels that have data and the `ST_MetaData <https://postgis.net/docs/RT_ST_MetaData.html>`_ function to provide all sorts of useful background info for our rasters."
msgstr ""

#: ../../en/rasters.rst:76
msgid "There are two levels of raster functions. There are functions such as ST_MetaData that work at the raster level and there are functions such as :command:`ST_Count` function and `ST_BandMetaData <https://postgis.net/docs/RT_ST_BandMetaData.html>`_ function that work at the band level. Most functions in postgis raster that work at the band level, work with only one band at a time, and assume the band you want is `1`."
msgstr ""

#: ../../en/rasters.rst:83
msgid "If you have a multi-band raster, and you need to count the pixel not no-data values in a band other than 1, you would explicitly specify the band number as follows `ST_Count(rast,2)`."
msgstr ""

#: ../../en/rasters.rst:85
msgid "Note how all the rasters have a 150x150 dimension.  This is not ideal. This means that in order to force that, our rasters, are squished in all sorts of ways.  If only we could see the ugliness of the rasters before us."
msgstr ""

#: ../../en/rasters.rst:89
msgid "Loading Rasters using raster2pgsql"
msgstr ""

#: ../../en/rasters.rst:90
msgid "`raster2pgsql <https://postgis.net/docs/using_raster_dataman.html#RT_Raster_Loader>`_ is a command-line tool often packaged with PostGIS. If you are on windows and used application stackbuilder PostGIS Bundle, you'll find :command:`raster2pgsql.exe` in the folder ``C:\\Program Files\\PostgreSQL\\15\\bin``  where the *15* should be replaced with the version of PostgreSQL you are running."
msgstr ""

#: ../../en/rasters.rst:93
msgid "If you are using Postgres.App, you'll find raster2pgsql among the other `Postgres.app CLI Tools <https://postgresapp.com/documentation/cli-tools.html>`_."
msgstr ""

#: ../../en/rasters.rst:95
msgid "On Ubuntu and Debian, you will need"
msgstr ""

#: ../../en/rasters.rst:101
msgid "to have the PostGIS commandline tools installed. This may install an additional version of PostgreSQL as well. You can see a list of clusters in Debian/Ubuntu using the :command:`pg_lsclusters` command and drop them using the :command:`pg_dropcluster` command."
msgstr ""

#: ../../en/rasters.rst:106
msgid "For this exercise, we'll use data from `NYC DEM 1-foot Integer <https://data.cityofnewyork.us/City-Government/1-foot-Digital-Elevation-Model-DEM-/dpc8-z3jc>`_."
msgstr ""

#: ../../en/rasters.rst:110
msgid "This digital elevation file is 3GB in size, we created a lower res version of it call `nyc_dem.tif` in the https://postgis.net/stuff/workshop-data/postgis_raster_workshop.zip `PG Raster Data Set <https://postgis.net/stuff/workshop-data/postgis_raster_workshop.zip>`_. In-lieu of loading the tif, restore the `nyc_dem.backup` included in the zip file in your database using the :command:`pg_restore` commandline tool or the pgAdmin **Restore** menu."
msgstr ""

#: ../../en/rasters.rst:116
msgid "The :command:`rasterpgsql` tool is similar to the :command:`shp2gpsql` except instead of loading ESRI shapefiles into PostGIS geometry/geography tables, it loads any GDAL supported raster format into raster tables. Just like :command:`shp2pgsql` you can pass it a spatial reference id (SRID) of the source. Unlike :command:`shp2pgsql` it can infer the spatial references system of the source data if your source data has suitable metadata."
msgstr ""

#: ../../en/rasters.rst:120
msgid "For a full exposure of all the possible switches offered refer to `raster2pgsql options <https://postgis.net/docs/using_raster_dataman.html#RT_Loading_Rasters>`_."
msgstr ""

#: ../../en/rasters.rst:122
msgid "Some other notable options :command:`raster2pgsql` offers which we will not cover are:"
msgstr ""

#: ../../en/rasters.rst:124
msgid "Ability to transform a raster spatial reference from its source to a preferred target srid"
msgstr ""

#: ../../en/rasters.rst:125
msgid "Ability to set the `nodata` value, when not specified, raster2pgsql tries to infer from the file"
msgstr ""

#: ../../en/rasters.rst:127
msgid "To load all the tif files in our folder and also create overviews, we would run the below."
msgstr ""

#: ../../en/rasters.rst:133
msgid "-d to drop the tables if they already exist"
msgstr ""

#: ../../en/rasters.rst:134
msgid "The above command uses `-e` to do load immediately instead of committing in a transaction"
msgstr ""

#: ../../en/rasters.rst:135
msgid "`-C` set raster constraints, this is useful for `raster_columns` to show info. You may wnat to combine with `-x` to exclude the extent constraint, which is a slow constraint to check and also hampers future loads in the table."
msgstr ""

#: ../../en/rasters.rst:138
msgid "`-Y` to use copy in batches of 50. If you are running PostGIS 3.3 or higher, you can use `-Y 1000` to have copy be in batches of 1000. This will run faster, but will use more memory."
msgstr ""

#: ../../en/rasters.rst:140
msgid "`-l 2,3` to create over view tables: `o_2_ncy_dem` and `o_3_nyc_dem`. This is useful for viewing data."
msgstr ""

#: ../../en/rasters.rst:141
msgid "-I to create a spatial index"
msgstr ""

#: ../../en/rasters.rst:142
msgid "`-F` to add file name, if you have only one tif file, this is kinda pointless. If you had multiple, this would be useful to tell you what file each row came from."
msgstr ""

#: ../../en/rasters.rst:144
msgid "`-t` to set the block size. Note if you are not sure the best size use, use `-t auto` instead and raster2pgql will use the same tiling as what was in the tif. The output will tell you what the blocksize is it chose. Cancel if it looks huge or weird. The original file had a size of 300x7 which is not ideal."
msgstr ""

#: ../../en/rasters.rst:148
msgid "Use :command:`psql` to run the generated sql against the database. If you want to dump to a file instead, use `> nyc_dem.sql`"
msgstr ""

#: ../../en/rasters.rst:152
msgid "For this example, we have only one tif file, so we could instead specify the full file name, instead of `*.tif`.  If the files are not in your current directory, you can also specify a folder path with `*.tif`."
msgstr ""

#: ../../en/rasters.rst:157
msgid "If you are on windows and need to reference the folder, make sure to include the drive letter such as `C:/workshop/*.tif`"
msgstr ""

#: ../../en/rasters.rst:160
msgid "You'll often hear in PostGIS lingo, the term **raster tile** and **raster** used somewhat interchangeably. A raster tile really corresponds to a particular raster in a raster column which is a subset of a bigger raster, such as this NYC dem data we just loaded. This is because when rasters are loaded into PostGIS from big raster files, they are often chopped up into many many rows to make them manageable.  Rasters are sadly limited by the 1GB PostgreSQL `TOAST <https://www.postgresql.org/docs/current/storage-toast.html>`_ limit and also the slow process of detoasting and so we need to chop up our raster data."
msgstr ""

#: ../../en/rasters.rst:168
msgid "Viewing Rasters in Browser"
msgstr ""

#: ../../en/rasters.rst:169
msgid "Although pgAdmin and psql have no mechanism yet to view postgis rasters, we have a couple of options. For smallish rasters the easiest is to output to a web-friendly raster format such as PNG using batteries included postgis raster functions like `ST_AsPNG` or `ST_AsGDALRaster` listed in `PostGIS Raster output functions <https://postgis.net/docs/RT_reference.html#Raster_Outputs>`_. As your rasters get larger, you'll want to graduate to a tool such as QGIS to view them in all their glory or the GDAL family of commandline tools such as :command:`gdal_translate` to export them to other raster formats.  Remember though, postgis rasters are built for analysis, not for generating pretty pictures for you to look at."
msgstr ""

#: ../../en/rasters.rst:176
msgid "One caveat, by default all different raster types outputs are disabled. In order to utilize these, you'll need to enable drivers, all or a subset as detailed in `Enable GDAL Raster drivers <https://postgis.net/docs/postgis_gdal_enabled_drivers.html>`_"
msgstr ""

#: ../../en/rasters.rst:184
msgid "If you don't want to have to do this for each connection, you can set at the database level using:"
msgstr ""

#: ../../en/rasters.rst:190
msgid "Each new connection to the database will use that setting."
msgstr ""

#: ../../en/rasters.rst:192
msgid "Run the below query and copy and paste the output into the address bar of your web browser."
msgstr ""

#: ../../en/rasters.rst:203
msgid "For the rasters created thus far, we didn't specify the number of bands nor did we even define their relation to earth.  As such our rasters have an unknown spatial reference system (0)."
msgstr ""

#: ../../en/rasters.rst:206
msgid "You can think of a rasters exoskeletal as a geometry. A matrix encased in a geometric envelop. In order to do useful analysis, we need to georeference our rasters, meaning we want each pixel (rectangle) to represent some meaningful plot of space."
msgstr ""

#: ../../en/rasters.rst:211
msgid "The `ST_AsRaster` has many overloaded representations. The earlier example used the simplest such implementation and accepted the default arguments which are 8BUI and 1 band, with no data being 0. If you need to use the other variants, you should use the named arguments call syntax so that you don't accidentally fall into the wrong variant of the function or get **function is not unique** errors."
msgstr ""

#: ../../en/rasters.rst:219
msgid "If you start with a geometry that has a spatial reference system, you'll end up with a raster with same spatial reference system. In this next example, we'll plop our words in New York in bright cheery colors. We will also use pixel scale instead of width and height so that our raster pixel sizes represent 1 meter x 1 meter of space."
msgstr ""

#: ../../en/rasters.rst:242
msgid "If we then look at this, we'll see a non-squashed colored geometry."
msgstr ""

#: ../../en/rasters.rst:253
msgid "Repeat for Raster:"
msgstr ""

#: ../../en/rasters.rst:264
msgid "What is more telling, if we rerun the"
msgstr ""

#: ../../en/rasters.rst:271
msgid "Observe the metadata of the New York entries. They have the New York state plane meter spatial reference system. They also have the same scale.  Since each unit is 1x1 meter, the width of the word **Raster** is now wider than **Hello**."
msgstr ""

#: ../../en/rasters.rst:286
msgid "Raster Spatial Catalog tables"
msgstr ""

#: ../../en/rasters.rst:287
msgid "Similar to the geometry and geography types, raster has a set of catalogs that show you all raster columns in your database. These are `raster_columns and raster_overviews <https://postgis.net/docs/using_raster_dataman.html#RT_Raster_Catalog>`_."
msgstr ""

#: ../../en/rasters.rst:293
msgid "raster_columns"
msgstr ""

#: ../../en/rasters.rst:295
msgid "The `raster_columns` view to the sibling to the  `geometry_columns` and `geography_columns`, providing much the same data and more, but for raster columns."
msgstr ""

#: ../../en/rasters.rst:303
msgid "Explore the table, and you'll find this:"
msgstr ""

#: ../../en/rasters.rst:315
msgid "a very disappointing row of largely unfilled information for the `rasters` table."
msgstr ""

#: ../../en/rasters.rst:317
msgid "Unlike geometry and geography, raster does not support type modifiers, because type modifier space is too limited and there are more critical properties than what can fit in a type modifier."
msgstr ""

#: ../../en/rasters.rst:320
msgid "Raster instead relies on constraints, and reads these constraints back as part of the view."
msgstr ""

#: ../../en/rasters.rst:322
msgid "Look at the other rows from the tables we loaded using :command:`raster2pgsql`. Because we used the `-C` switch :command:`raster2pgsql` added constraints for the srid and other info it was able to read from the tif or that we passed in. The overview tables generated with the `-l` switch `o_2_nyc_dem` and `o_3_nyc_dem` show up as well."
msgstr ""

#: ../../en/rasters.rst:325
msgid "Let's try to add some constraints to our table."
msgstr ""

#: ../../en/rasters.rst:332
msgid "And you'll be bombarded with a whole bunch of notices about how your raster data is a mess and nothing can be constrained. If you look at raster_columns again, still the same disappointing story of many blank rows for `rasters`."
msgstr ""

#: ../../en/rasters.rst:336
msgid "In order for constraints to be applied, all rasters in your table must be constrainable by at least one rule."
msgstr ""

#: ../../en/rasters.rst:339
msgid "We can perhaps do this, let's just lie and say all our data is in New York State plane."
msgstr ""

#: ../../en/rasters.rst:352
msgid "Ah progress:"
msgstr ""

#: ../../en/rasters.rst:361
msgid "The more you can constrain all your rasters, the more columns you'll see filled in and also the more operations you'll be able to do across all the tiles in your raster. Keep in mind that in some cases, you may not want to apply all constraints."
msgstr ""

#: ../../en/rasters.rst:365
msgid "For example, if you plan to load more data into your raster table, you'll want to skip the extent constraint since that would require that all rasters are within the extent of the extent constraint."
msgstr ""

#: ../../en/rasters.rst:370
msgid "raster_overviews"
msgstr ""

#: ../../en/rasters.rst:371
msgid "Raster overview columns appear both in the `raster_columns` meta catalog and another meta catalog called `raster_overviews`. Overviews are used mostly to speed up viewing at higher zoom levels. They can also be used for quick back of the envelop analysis, providing less accurate stats, but at a much faster speed than applying to the raw raster table."
msgstr ""

#: ../../en/rasters.rst:376
msgid "To inspect the overviews, run:"
msgstr ""

#: ../../en/rasters.rst:383
msgid "and you'll see the output:"
msgstr ""

#: ../../en/rasters.rst:393
msgid "The `raster_overviews` table only provides you the overview_factor and the name of the parent table. All this information is something you could have figured out yourself by the `raster2pgsql` naming convention for overviews."
msgstr ""

#: ../../en/rasters.rst:397
msgid "The `overview_factor` tells you at what resolution the row is with respect to it's parent. An `overview_factor` of `2` means that 2x2 = 4 tiles can fit into one overview_2 tile. Similarly an overview_factor of `1` meants that 2x2x2 = 8 tiles of the original can be shoved into an overview_3 tile."
msgstr ""

#: ../../en/rasters.rst:404
msgid "Exploring Raster Functions"
msgstr ""

#: ../../en/rasters.rst:405
msgid "The :command:`postgis_raster` extension has over 100 functions to choose from. We'll focus on the ones you will commonly use. PostGIS raster functionality was patterned after the PostGIS geometry support. As such you'll find an overlap of functions between raster and geometry where it makes sense. Common ones you'll use that have equivalent in geometry world are :command:`ST_Intersects`, :command:`ST_SetSRID`, :command:`ST_SRID`, :command:`ST_Union`, :command:`ST_Intersection`, and :command:`ST_Transform`. In addition to those overlapping functions, it offers many functions that work in conjunction with geometry or are very specific to rasters."
msgstr ""

#: ../../en/rasters.rst:414
msgid "Unioning Rasters"
msgstr ""

#: ../../en/rasters.rst:415
msgid "The `ST_Union <https://postgis.net/docs/RT_ST_Union.html>`_ function for raster, just as the geometry equivalent :command:`ST_Union`, aggregates a set of rasters together into a single raster.  However, just as with geometry, not all rasters can be combined together, but the rules for raster unioning are more complicated than geometry rules. In the case of geometries, all you need is to have the same spatial reference system, but for rasters that is not sufficient."
msgstr ""

#: ../../en/rasters.rst:423
msgid "If you were to attempt, the following"
msgstr ""

#: ../../en/rasters.rst:430
msgid "You'd be summarily punished with an error:"
msgstr ""

#: ../../en/rasters.rst:432
msgid "**ERROR:  rt_raster_from_two_rasters: The two rasters provided do not have the same alignment SQL state: XX000**"
msgstr ""

#: ../../en/rasters.rst:435
msgid "What is this same alignment thing, that is preventing you from unioning your precious rasters?"
msgstr ""

#: ../../en/rasters.rst:437
msgid "In order for rasters to be combined, they need to be on the same grid so to speak. Meaning they must have same pixel sizes, same orientation (the skew), same spatial reference system, and their pixels must not cut into each other, meaning they share the same worldly pixel grid."
msgstr ""

#: ../../en/rasters.rst:441
msgid "If you try the same query, but just with words we carefully placed in New York."
msgstr ""

#: ../../en/rasters.rst:443
msgid "Again, the same error. These are the same spatial ref system, the same pixel sizes, and yet it's still not good enough. Because their grids are off."
msgstr ""

#: ../../en/rasters.rst:447
msgid "We can fix this by shifting the upper left y coordinates ever so slightly and then trying again. If our grids start at integer level since our pixel sizes are whole integer, then the pixels won't cut into each other."
msgstr ""

#: ../../en/rasters.rst:462
#: ../../en/rasters.rst:511
msgid "Voila it worked, and if we were to view, we'd see something like this:"
msgstr ""

#: ../../en/rasters.rst:468
msgid "If ever you are unclear why your rasters don't have the same alignment, you can use the function `ST_SameAlignment <https://postgis.net/docs/RT_ST_SameAlignment.html>`_, which will compare 2 rasters or a set of rasters and tell you if they have the same alignment.  If you have notices enabled, the NOTICE will tell you what is off with the rasters in question. The `ST_NotSameAlignmentReason <https://postgis.net/docs/RT_ST_NotSameAlignmentReason.html>`_, instead of just a notice will output the reason. It however only works with two rasters at a time."
msgstr ""

#: ../../en/rasters.rst:475
msgid "One major way in which the `ST_Union(raster) <https://postgis.net/docs/RT_ST_Union.html>`_ raster function deviates from the `ST_Union(geometry) <https://postgis.net/docs/ST_Union.html>`_ geometry function is that it allows for an argument called *uniontype*.  This argument by default is set to `LAST` if you don't specify it, which means, take the **LAST** raster pixel values in occasions where the raster pixel values overlap. As a general rule, pixels in a band that are marked as no-data are ignored."
msgstr ""

#: ../../en/rasters.rst:481
msgid "Just as with most aggregates in PostgreSQL, you can put a :command:`ORDER BY` clause as part of the function call as is done in the prior example.  Specifying the order, allows you to control which raster takes priority. So in our prior example, *Raster* trumped *Hello* because *Raster* is alphabetically last."
msgstr ""

#: ../../en/rasters.rst:485
msgid "Observe, if you switch the order:"
msgstr ""

#: ../../en/rasters.rst:495
msgid "Then *Hello* trumps *Raster* because Hello is now the last overlaid."
msgstr ""

#: ../../en/rasters.rst:497
msgid "The :command:`FIRST` union type is the reverse of :command:`LAST`."
msgstr ""

#: ../../en/rasters.rst:499
msgid "But on occassion, **LAST** may not be the right operation. Let's suppose our rasters represented two different sets of observations from two different devices. These devices measure the same thing, and we aren't sure which is right when they cross paths, so we'd instead like to take the `MEAN` of the results.  We'd do this:"
msgstr ""

#: ../../en/rasters.rst:515
msgid "So instead of trumping, we have a blending of the two forces. In the case of :command:`MEAN` union type, there is no point in specifying order, because the result would be the average of overlapping pixel values."
msgstr ""

#: ../../en/rasters.rst:519
msgid "Note that for geometries since geometries are vector and thus have no values besides there or not there, there really isn't any ambiguity on how to combine two vectors when they intersect."
msgstr ""

#: ../../en/rasters.rst:523
msgid "Another feature of the raster :command:`ST_Union` we glossed over, is this idea of if you should return all bands or just some bands. When you don't specify what bands to union, :command:`ST_Union` will combine same banded numbers and use the :command:`LAST` unioning strategy.  If you have multiple bands, this may not be what you want to do. Perhaps you only want to union, the second band. In this case, the Green Band and you want the count of pixel values."
msgstr ""

#: ../../en/rasters.rst:544
msgid "Note in the case of the **COUNT** union type, which counts the number of pixels filled in and returns that value, the result is always a **32BUI** similar to how when you do a :command:`COUNT` in sql, the result is always a bigint, to accommodate large counts."
msgstr ""

#: ../../en/rasters.rst:548
msgid "In other cases, the band pixel type does not change and is set to the max value or rounded if the amounts exceed the bounds of the type. Why would anyone ever want to count pixels that intersect at a location. Well suppose each of your rasters represent police squadrons and incidents of arrests in the areas. Each value, might represent a different kind of arrest reason. You are doing stats on how many arrests in each region, therefore you only care about the count of arrests."
msgstr ""

#: ../../en/rasters.rst:557
msgid "Or perhaps, you want to do all bands, but you want different strategies."
msgstr ""

#: ../../en/rasters.rst:567
msgid "Using the *unionarg[]* variant of the :command:`ST_Union` function, also allows you to shuffle the order of the bands."
msgstr ""

#: ../../en/rasters.rst:570
msgid "Clipping Rasters"
msgstr ""

#: ../../en/rasters.rst:571
msgid "The `ST_Clip <https://postgis.net/docs/RT_ST_Clip.html>`_ function is one of the most widely used functions for PostGIS rasters.  The main reason is the more pixels you need to inspect or do operations on, the slower your processing. **ST_Clip** clips your raster to just the area of interest, so you can isolate your operations to just that area."
msgstr ""

#: ../../en/rasters.rst:575
msgid "This function is also special in that it utilizes the power of geometry to help raster analysis. To reduce the number of pixels, :command:`ST_Union` has to handle, each raster is clipped first to the area we are interested in."
msgstr ""

#: ../../en/rasters.rst:587
msgid "This example showcases several functions working in unison.  The :command:`ST_Intersects` function employed is the one packaged with **postgis_raster** and can intersect 2 rasters or a raster and a geometry. Similar to the geometry :command:`ST_Intersects` the raster :command:`ST_Intersects` can take advantage of spatial indexes on the raster or geometry tables."
msgstr ""

#: ../../en/rasters.rst:593
msgid "Converting Rasters to Geometries"
msgstr ""

#: ../../en/rasters.rst:594
msgid "Rasters can just as easily be morphed into geometries. Lets start with our prior example, but convert it to a polygon using `ST_Polygon <https://postgis.net/docs/RT_ST_Polygon.html>`_ function."
msgstr ""

#: ../../en/rasters.rst:606
msgid "If you click on the geometry viewer in pgAdmin, you can see this in all it's glory without any hacks."
msgstr ""

#: ../../en/rasters.rst:610
msgid "ST_Polygon considers all the pixels that have values (not no-data) in a particular band, and converts them to geometry.  Like many other functions in raster, ST_Polygon only considers 1 band. If no band is specified, it will consider only the first band."
msgstr ""

#: ../../en/rasters.rst:614
msgid "Another popularly used function is the `ST_PixelAsPolygons <https://postgis.net/docs/RT_ST_PixelAsPolygons.html>`_ function. You should rarely use :command:`ST_PixelAsPolygons` on a large raster without first clipping because you will end up with millions of rows, one for each pixel."
msgstr ""

#: ../../en/rasters.rst:617
msgid ":command:`ST_PixelAsPolygons` returns a table consisting of geom, val, x, and y. Where x is the column number, and y is the row number in the raster."
msgstr ""

#: ../../en/rasters.rst:620
msgid ":command:`ST_PixelAsPolygons` similar to other raster functions works on one band at a time and works on band 1 if no band is specified. It also by default returns only pixels that have values."
msgstr ""

#: ../../en/rasters.rst:632
msgid "Which outputs:"
msgstr ""

#: ../../en/rasters.rst:636
msgid "and if we inspect using the geometry viewer, we'd see:"
msgstr ""

#: ../../en/rasters.rst:640
msgid "If we want all pixels of all our bands, we'd need to do something like below. Note the differences in this example from previous."
msgstr ""

#: ../../en/rasters.rst:643
msgid "1. Setting  :command:`exclude_nodata_value` to make sure all pixels are returned so that our sets of calls return the same number of rows. The rows out of the function will be naturally in the same order."
msgstr ""

#: ../../en/rasters.rst:646
msgid "2. Using the `PostgreSQL ROWS FROM constructor <https://www.postgresql.org/docs/current/queries-table-expressions.html#QUERIES-TABLEFUNCTIONS>`_ , and aliasing each set of columns from our function output with names. So for example the band 1 columns (geom, val, x, y) are renamed to g1, v1, x1, x2"
msgstr ""

#: ../../en/rasters.rst:667
msgid "We used CROSS JOIN LATERAL in these examples because we wanted to be explicit what we are doing. Since these are all set returning functions, you can replace CROSS JOIN LATERAL with , for short-hand.  We'll use a , in the next set of examples"
msgstr ""

#: ../../en/rasters.rst:672
msgid "Raster also introduces an additional composite type called a :command:`geomval`. Consider a :command:`geomval` as the offspring of a geometry and raster. It contains a geometry and it contains a pixel value."
msgstr ""

#: ../../en/rasters.rst:676
msgid "You will find several raster functions that return geomvals."
msgstr ""

#: ../../en/rasters.rst:678
msgid "A commonly used function that outputs geomvals is `ST_DumpAsPolygons <https://postgis.net/docs/RT_ST_DumpAsPolygons.html>`_, which returns a set of contiguous pixels with the same value as a polygon.  Again this by default will only check band 1 and exclude no data values unless you override. This example selects only polygons from band 2. You can also apply filters to the values. For most use cases, :command:`ST_DumpAsPolygons` is a better option than :command:`ST_PixelAsPolygons` as it will return far fewer rows."
msgstr ""

#: ../../en/rasters.rst:683
msgid "This will output 6 rows, and return polygons corresponding to the letters in \"Raster\"."
msgstr ""

#: ../../en/rasters.rst:694
msgid "Note that it doesn't return a single geometry, because it finds continguous set of pixels with the same value that form a polygon. Even though all these values are the same, they are not continguous."
msgstr ""

#: ../../en/rasters.rst:700
msgid "A common approach to produce more complex geometries is to group by the values and union."
msgstr ""

#: ../../en/rasters.rst:710
msgid "This will give you 2 rows back corresponding to the words \"Raster\" and \"Hello\"."
msgstr ""

#: ../../en/rasters.rst:713
msgid "Basic statistics"
msgstr ""

#: ../../en/rasters.rst:714
msgid "The most important thing to understand about rasters is that they are statistical tools for storing data in arrays, that you may happen to be able to make look pretty on a screen."
msgstr ""

#: ../../en/rasters.rst:717
msgid "You can find a menu of these statistical functions in `Raster Band Statistics <https://postgis.net/docs/RT_reference.html#RasterBand_Stats>` _."
msgstr ""

#: ../../en/rasters.rst:720
msgid "This query takes about 10 seconds: .. code-block:: sql"
msgstr ""

#: ../../en/rasters.rst:724
msgid "SELECT (ST_SummaryStatsAgg(rast, 1, true, 1)).* AS sa"
msgstr ""

#: ../../en/rasters.rst:724
msgid "FROM nyc_dem;"
msgstr ""

#: ../../en/rasters.rst:726
msgid "Outputs:"
msgstr ""

#: ../../en/rasters.rst:735
msgid "Which tells we have a lot of pixels and our max elevation is 411 ft."
msgstr ""

#: ../../en/rasters.rst:737
msgid "Now armed with this bit of information, we can ask more questions."
msgstr ""

#: ../../en/rasters.rst:740
msgid "The intersection and transformation of rasters"
msgstr ""

#: ../../en/rasters.rst:742
msgid "Just as you can compute the intersection of two geometries using `ST_Intersection`, you can compute intersection of two rasters or a raster and a geometry using `raster ST_Interection <https://postgis.net/docs/RT_ST_Intersection.html>`_."
msgstr ""

#: ../../en/rasters.rst:746
msgid "What you get out of this beast, are two different kinds of things:"
msgstr ""

#: ../../en/rasters.rst:748
msgid "Intersect a geometry with a raster, and you get a set of `geomval` offspring. Not just one but possibly many."
msgstr ""

#: ../../en/rasters.rst:750
msgid "Intersect 2 rasters and you get a single `raster` back"
msgstr ""

#: ../../en/rasters.rst:752
msgid "The golden rule for both raster intersection and geometry intersection is that both parties involved must have the same spatial reference system. For raster/raster, they have to have same alignment."
msgstr ""

#: ../../en/rasters.rst:756
msgid "We'll have no problem intersecting our geometry with our `Hello Raster` rasters, because they are both in NY State plane meters, however the story is not so simple with our elevation data which is in NY State plane feet."
msgstr ""

#: ../../en/rasters.rst:761
msgid "As a general rule, transforming geometries, is an easier process than transforming rasters, so when you need to do on the fly, transform the geometry. If you plan to do this often rebuild one of tables so that your datasets are in the same spatial reference system."
msgstr ""

#: ../../en/rasters.rst:765
msgid "Here is an example of on-the-fly transformation of the geometry. Which answers a very important question. If we bucket our elevations into 5 buckets of elevation values, which elevation range results in the most gun fatalities."
msgstr ""

#: ../../en/rasters.rst:785
msgid "Is there an important correlation between gun homicides and elevation? Probably not."
msgstr ""

#: ../../en/rasters.rst:790
msgid "Map Algebra Functions"
msgstr ""

#: ../../en/rasters.rst:791
msgid "Map algebra is the idea that you can do math on your pixel values. The :command:`ST_Union` function covered earlier is a special fast case of map algebra. Then there are the `ST_MapAlgebra <https://postgis.net/docs/RT_ST_Polygon.html>`_ family of functions which allow you to define your own crazy math, but at cost of performance."
msgstr ""

#: ../../en/rasters.rst:797
msgid "People have the habit of jumping to  :command:`ST_MapAlgebra`, probably cause the name sounds so cool and sophisticated. Who wouldn't want to tell their friends, \"I'm using a function called ST_MapAlgebra.\" My advice, explore other functions before you jump for that shot-gun. Your life will be simpler and your performance will be 100 times better, and your code will be shorter."
msgstr ""

#: ../../en/rasters.rst:803
msgid "An often overlooked map-algebraish function is the `ST_Reclass <https://postgis.net/docs/RT_ST_Reclass.html>`_ function, who sits in the background waiting for someone to discover the power and speed it can offer."
msgstr ""

#: ../../en/rasters.rst:807
msgid "What does **ST_Reclass** do? It as the name implies, reclassifies your pixel values based on minimalist range algebra."
msgstr ""
